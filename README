Fast compact serialization for Lua
==========================

local freezer = require "freezer"

Provides:
---------

* s = freezer.freeze(v[, constants], ...) - serializes a value to a byte stream
* t = freezer.thaw(s[, constants])      - deserializes a byte stream to a value
* t = freezer.clone(orig[, constants])  - deep clone a value (deep for tables
                                          and functions)

The freezer.freeze function takes an optional third and forth boolean
argument.  When the third argument is true all duplicates of a given string
are stored as brief references.  If built for LuaJIT, the fourth argument
enables debug stripping, otherwise it is ignored.  Both of these default to
false.

N.B. string deduplication requires strings to be checked against a hash table
which will slow down the serialization.  Nontheless, this may be useful for
structures with lots of repeated strings or containing closures with
identical bytecode.

For the sake of compatibility with other serialization libraries, encode
is a synonym for freeze, and decode is a synonym for thaw.

Freezer provides Lua C API style calls as:

    freezer_freeze(lua_State *L);
    freezer_thaw(lua_State *L);

There is no C API for clone.

Features:
---------

Serializes tables, which may contain cycles, Lua functions with upvalues and
basic data types.

All functions take an optional constants table which, if encountered during
serialization, are simply referenced from the constants table passed during
deserialization. For example:

    local orig = { answer = 42, print = print }
    local pack = freezer.freeze(orig, { print })
    local copy = freezer.thaw(pack, { print })
    assert(copy.print == print)


Hooks
-----

A hook is provided for influencing serializing behaviour via the `__freeze`
metamethod.  The `__freeze` metamethod is expected to return a closure which
is called during deserialization. The return value of the closure is taken as
the final thawed result.

This is useful for serializing both userdata and for use with object-oriented
Lua, since metatables are not serialized.

For example:

    local Point = { }
    function Point:new(x, y)
       self.__index = self
       return setmetatable({ x = x, y = y }, self)
    end
    function Point:move(x, y)
       self.x = x
       self.y = y
    end
    function Point:__freeze()
       local x = self.x
       local y = self.y
       return function()
          -- do NOT refer to self in this scope
          return setmetatable({ x = x, y = y }, Point)
       end
    end

The above shows a way to store an "instance" of Point (if you're thinking in
OO terms). In this case `Point` itself will be included in the frozen chunk
because it's referenced as an upvalue of the returned closure.

The `__freeze` hook may *NOT* refer to the receiver (i.e. `self` in the
example) because this will cause deep recursion when upvalues are serialized.

Limitations: ------------

Coroutines are not serialized. Userdata doesn't serialize either however
support for userdata the `__freeze` metatable hook can be used.

Metatables and function environments are not serialized.

Attempt to serialize threads, C functions, and userdata without a `__freeze`
hook raises an exception.

Serialized code may not be portable.
